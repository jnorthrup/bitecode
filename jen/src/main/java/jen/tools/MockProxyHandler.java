/* MockProxyHandler.java - Invocation handler for mock object proxies
 *
 * Copyright (c)2005 Roscopeco Open Technologies & Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * File version: $Revision: 1.5 $ $Date: 2005/10/31 01:50:46 $
 * Originated: Oct 6, 2005
 * Author: Ross Bamford (rosco<at>roscopeco.co.uk)
 */

package jen.tools;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

import static java.util.Arrays.asList;
import static java.util.Collections.unmodifiableList;
import static jen.tools.Toolbox.primitiveClassIdent;

/** 
 * Provides support for <em>mock object</em> proxy generation
 * with {@link SoftProxy}. This support is 
 * implemented via an {@link InvocationHandler} implementation that can be used
 * with any platform-compatible proxy implementation, including platform proxies 
 * themselves, and those generated with Jen {@link SoftProxy} and (via an adapter) 
 * Cglib's {@code Proxy} implementation. Supplying an instance of this handler to 
 * a proxy instance will create a basic mock implementation of the proxied classes
 * and/or interfaces, useful for use in development, testing, and evaluation, for 
 * example.
 * <p/>
 * In order to use {@code MockProxyHandler} with a proxy, simply provide an appropriate
 * class (or array of classes) and array of {@link MockMethod} instances to one of static 
 * helper methods ({@link #newMockInstance(Class, MockMethod[])} or 
 * {@link #newMockInstance(Class[], MockMethod[])}). These static helpers can be used 
 * in situations where you just need a mock instance, and completely wrap the process
 * of creating a proxy class and instantiating it with a suitable mock handler.
 * Alternatively, create a new instance of this class manually, and supply it to a 
 * platform-compatible proxy constructor. When created by this means {@code MockProxyHandler}
 * mocks can be created with both Jen <em>default proxies</em> and any other platform 
 * compatible proxy, such as those generated by Cglib and the platform itself.
 * <p/> 
 * Mock method implementations are supplied as a list (or array) of 
 * {@code MockMethod} implementations passed to the handler at instantiation.
 * The {@link StubMock} class provides a general implementation that 
 * allows another {@code InvocationHandler} to actually handle the method, 
 * along with standard stubs to return a constant value and throw a specific 
 * exception.
 * <p/>
 * When creating {@code MockProxyHandler} instances it is not necessary to supply a
 * {@code MockMethod} instance for each proxied method - any invocation for which
 * no matching implementation is found will be dispatched to the default mock handler,
 * which simply returns {@code null}, zero or {@code false} as appropriate.
 * <p/>
 * <strong>Implementation Note</strong>: Since the primary intended scenario for
 * mocks is unit testing, this handler is not designed to give maximum performance.
 * A primary aim in the architecture of this class is that a reasonable balance is
 * achieved between ease of use and expressive code, and runtime performance of 
 * mock proxy invocations, and the result should be more than adequate for all but
 * the most performance-critical of systems.
 *
 * @author Ross Bamford (rosco&lt;at&gt;roscopeco.co.uk)
 * @version $Revision: 1.5 $ $Date: 2005/10/31 01:50:46 $ 
 */
public class MockProxyHandler implements InvocationHandler
{
  static final Number DEFAULT_WRAPPED_PRIMITIVE = new Integer(0);
  
  /* **********************************
   * INSTANCE
   */
  private final List<MockMethod> mocks;
    
  private final MockMethod defaultMock = this.new DefaultMockMethod();
  
  /**
   * Returns the default {@link MockMethod} implementation. This is provided for
   * use by subclasses.
   * 
   * @return The default {@code MockMethod}, which matches any invocation and 
   *         always returns {@code null}.
   */
  protected final MockMethod defaultMock() {
    return defaultMock;
  }
  
  /**
   * Create a new {@code MockProxyHandler} to handle the supplied {@link MockMethod}
   * invocations. The new handler is then used with a proxy instance to dispatch the
   * specified method invocations to the appropriate {@code MockMethod}.
   * 
   * @param methods A {@link List} of {@link MockMethod} instances representing the
   *        custom mock invocations for the new handler.
   */  
  public MockProxyHandler(List<MockMethod> methods) {
    ArrayList<MockMethod> t = new ArrayList<MockMethod>(methods != null ? methods.size() : 0);
    if (methods != null) t.addAll(methods);    
    mocks = unmodifiableList(t);
  }
  
  /**
   * Create a new {@code MockProxyHandler} to handle the supplied {@link MockMethod}
   * invocations. The new handler is then used with a proxy instance to dispatch the
   * specified method invocations to the appropriate {@code MockMethod}.
   * <p/>
   * This version accepts an array parameter, and is provided for the ease of 
   * creating a static array in code.
   * 
   * @param methods An array of {@link MockMethod} instances representing the
   *        custom mock invocations for the new handler.
   */  
  public MockProxyHandler(MockMethod[] methods) {
    this(asList(methods));        
  }
  
  /**
   * Finds an appropriate {@link MockMethod} implementation that indicates it can
   * handle the specified invocation. This method is {@code protected} to allow
   * subclasses to modify the strategy used to store and find mock methods.
   * 
   * @param proxy The proxy instance the invocation was made through.
   * @param method The actual (proxied) method being invoked.
   * @param args The arguments passed.
   * 
   * @return An appropriate {@code MockMethod}, or the default if no matching
   *         mock method is found. 
   */
  protected MockMethod findMockFor(Object proxy, Method method, Object[] args) {
    for (MockMethod mm : mocks) {
      if (mm.invocationMatches(proxy,method,args)) {
        return mm;
      }      
    }
    return defaultMock;    
  }
  
  /**
   * Handle the specified proxied {@link Method} invocation. This will dispatch
   * the method call to the first matching {@link MockMethod}, or to the 
   * default method if no match is found.
   */
  public Object invoke(Object proxy, Method method, Object[] args)
      throws Throwable {
    return findMockFor(proxy, method, args).invoke(proxy,method,args);
  }
  
  /* **********************************
   * DEFAULT INVOCATION HANDLER
   */
  final class DefaultMockMethod implements MockMethod {    
    public boolean invocationMatches(Object proxy, Method method, Object[] args) {
      return true;
    }

    public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable {
      Class<?> mr = method.getReturnType();
      
      if (mr.isPrimitive()) {
        // special handling of primitives
        char primId = primitiveClassIdent(mr);
        
        // there would be a cleaner way to do this, except the damn wrappers
        // use different method names, and we need special handling for bool
        // and char types :(
        switch (primId) {
          case 'B' :
            return DEFAULT_WRAPPED_PRIMITIVE.byteValue();
          case 'C' : 
            return (char)0;
          case 'D' : 
            return DEFAULT_WRAPPED_PRIMITIVE.doubleValue();
          case 'F' : 
            return DEFAULT_WRAPPED_PRIMITIVE.floatValue();
          case 'I' : 
            return DEFAULT_WRAPPED_PRIMITIVE.intValue();
          case 'J' : 
            return DEFAULT_WRAPPED_PRIMITIVE.longValue();
          case 'S' : 
            return DEFAULT_WRAPPED_PRIMITIVE.shortValue();
          case 'V' : 
            return null;
          case 'Z' : 
            return false;
          default  : throw(new IllegalArgumentException("Encountered unrecognised primitive type '"+mr+"'"));
        }        
      }
      
      return null;
    }
  }
}
